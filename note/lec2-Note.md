### Lecture 2 Functions

1. **value** 程序所要操作的对象
2. 函数调用表达式    
$$
(operator \quad [operand] \quad ...)
$$
表达式的求值顺序是从 $operator$ 开始，从左到右依次求值，之后将 $operator$ 应用于 $operand$ 上
3. 函数的分类
    · 纯函数 (**Pure Function**)
    · 带有副作用的函数
    纯函数: 输出仅依赖于输入，且调用函数时只进行计算而不进行其余额外操作
4. 表达式的分类
    · 函数调用表达式
    · 特殊形式表达式 (**special form**)
5. 动态语言中的函数环境模型
```python
x, y = 1, 12
def g1(x):
    def g2(x):
        print(x)
    g2(x + 1)
g1(2)
```
Q: 上述程序的打印结果是?
```python
1. x, y = 1, 12              # 执行变量声明  将 (x, 1) (y, 12) 对加入当前环境中
2. def g1(x)                 # 执行函数声明 先创建函数对象，再将 (g1, [g1 addr]) 对加入当前环境中
3. [g1 addr](2)              # 执行 g1(2) 首先对函数(g1)求值 （遇到 symbol 时，在环境中查找，然后用对应值来替换）
4. | x = 2 | <-- 函数调用时创建的新环境 (g1 frame)         # 在函数调用时，首先创建一个新环境，然后将形参值放入此环节
5. def g2(x)                 # 在创建新环境后，就只是简单地以新环境为当前环境，并执行函数内部的语句，此语句为
                             # 函数声明语句，与步骤2类似
6. [g2 addr](x + 1)          # 执行 g2(x + 1) 首先对g2求值
7. [g2 addr](x [+ addr] 1)   # 对 x + 1 求值，由于其为函数调用表达式，故先对函数(+)求值
8. [g2 addr](2 [+ addr] 1)   # 对 x 求值，在环境中查找 Symbol 的顺序为由低向上查询，当前环境如下所示
---- golbal frame ----
|       (x, 1)       |   # 步骤 1 定义
|       (y, 12)      |   # 步骤 1 定义
|   (g1, [g1 addr])  |   # 步骤 2 定义
------ g1 frame ------ parent = global frame
|       (x, 2)       |   # 形参
|   (g2, [g2 addr])  |   # 步骤 5 定义
9. | x = 3 | <-- g2 frame    # 调用函数 g2 ，创建新环境
10. [print addr](x)          # 执行 print(x) 首先对 print 求值
11. [print addr](3)          # 对 x 求值，当前环境如下所示
---- golbal frame ----
|       (x, 1)       |   # 步骤 1 定义
|       (y, 12)      |   # 步骤 1 定义
|   (g1, [g1 addr])  |   # 步骤 2 定义
------ g1 frame ------ parent = global frame
|       (x, 2)       |   # 形参
|   (g2, [g2 addr])  |   # 步骤 5 定义
------ g2 frame ------ parent = g1 frame
|       (x, 3)       |   # 形参
12. 打印值3到屏幕上，之后依次退出函数，但是退出函数后环境是否销毁需要根据具体情况讨论（闭包）
13. 上述讨论详见 Lec3 16:58
```
6. 函数的定义
在定义函数时，首先会创建一个匿名函数对象(和用 $lambda$ 算子定义的相同)，并在对象内部定义一个指针，指向定义它的环境。之后在调用函数时创建的新环境以定义它的环境为父环境(在图示中即为新环境挂在定义它的环境正下方)。正是这种机制实现了闭包。